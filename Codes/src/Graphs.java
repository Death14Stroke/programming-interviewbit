import java.util.*;

class Graphs {
    // https://www.interviewbit.com/problems/region-in-binarymatrix/
    static int largestRegion(int[][] A) {
        int m = A.length, n = A[0].length;
        // length of largest connected component
        int res = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // unvisited node - start dfs
                if (A[i][j] == 1)
                    res = Math.max(res, dfs(i, j, A));
            }
        }

        return res;
    }

    // util to count no of nodes traversed in dfs
    private static int dfs(int i, int j, int[][] A) {
        // already visited node
        if (A[i][j] == 0)
            return 0;

        // mark current node as visited
        A[i][j] = 0;

        // 8 directions in which we can move ahead
        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};
        int m = A.length, n = A[0].length;
        // no of nodes traversed in current dfs
        int noOfNodes = 1;

        // for each direction
        for (int[] dir : dirs) {
            int x = i + dir[0], y = j + dir[1];
            // if path does not exist
            if (x < 0 || x >= m || y < 0 || y >= n)
                continue;

            // add no of nodes traversed in this direction to total
            noOfNodes += dfs(x, y, A);
        }

        return noOfNodes;
    }

    // https://www.interviewbit.com/problems/level-order/
    @SuppressWarnings("ConstantConditions")
    static ArrayList<ArrayList<Integer>> levelOrder(Trees.TreeNode root) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        // empty tree
        if (root == null)
            return res;

        // queue for level order traversal
        Queue<Trees.TreeNode> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {
            int n = q.size();
            ArrayList<Integer> level = new ArrayList<>();

            // traverse current level
            for (int i = 0; i < n; i++) {
                Trees.TreeNode front = q.poll();
                // add node to current level
                level.add(front.val);

                // append next level nodes to queue
                if (front.left != null)
                    q.add(front.left);
                if (front.right != null)
                    q.add(front.right);
            }

            res.add(level);
        }

        return res;
    }

    // https://www.interviewbit.com/problems/snake-ladder-problem/
    static int snakesAndLadders(int[][] A, int[][] B) {
        // create edge map for all the ladders and snakes
        int[] edges = new int[101];
        for (int[] ladder : A)
            edges[ladder[0]] = ladder[1];
        for (int[] snake : B)
            edges[snake[0]] = snake[1];

        // visited array for BFS
        boolean[] visited = new boolean[101];
        // queue for BFS
        Queue<GameNode> q = new LinkedList<>();
        // flag to check whether solution was found or not
        boolean isValid = false;

        // start from 1
        GameNode front = new GameNode();
        front.v = 1;
        front.dist = 0;

        visited[1] = true;
        q.add(front);

        // since in the board game all edges will have equal weight, BFS will give us the shortest path
        while (!q.isEmpty()) {
            front = q.poll();
            int v = front.v;

            // reached end. Mark valid flag as true and return
            if (v == 100) {
                isValid = true;
                break;
            }

            // try all 6 possible numbers on dice
            for (int j = v + 1; j <= (v + 6) && j <= 100; j++) {
                if (visited[j])
                    continue;

                // visit new node
                GameNode node = new GameNode();
                node.dist = front.dist + 1;
                visited[j] = true;

                // if any ladder or snake present, move up/down along that
                if (edges[j] != 0)
                    node.v = edges[j];
                else
                    node.v = j;

                q.add(node);
            }
        }

        // if solution not found return -1
        return isValid ? front.dist : -1;
    }

    // data class for each position on the board
    static class GameNode {
        // vertex on the board
        int v;
        // distance currently travelled
        int dist;
    }

    // https://www.interviewbit.com/problems/smallest-multiple-with-0-and-1/
    static String smallestMultiple(int n) {
        // base case
        if (n == 0)
            return "0";

        // start BFS from "1"
        Queue<StringNode> q = new LinkedList<>();
        q.add(new StringNode('1', 1, null));
        // set to check if remainder is seen or not. A smaller string with same remainder will generate
        // all the possible remainders that can be generated by a larger string with same remainder
        boolean[] remainderSet = new boolean[n];
        // last digit in the result string
        StringNode head = null;

        while (!q.isEmpty()) {
            StringNode front = q.poll();

            // found required number
            if (front.remainder % n == 0) {
                head = front;
                break;
            }

            // if remainder not seen before, perform BFS
            if (!remainderSet[front.remainder]) {
                remainderSet[front.remainder] = true;
                q.add(new StringNode('0', (front.remainder * 10) % n, front));
                q.add(new StringNode('1', (front.remainder * 10 + 1) % n, front));
            }
        }

        // build the reverse number
        StringBuilder builder = new StringBuilder();
        while (head != null) {
            builder.append(head.c);
            head = head.prev;
        }

        return builder.reverse().toString();
    }

    /// data class for BFS node
    static class StringNode {
        // current character in the result string
        char c;
        // remainder of the string formed till now
        int remainder;
        // pointer to the previous char's node in the string
        StringNode prev;

        StringNode(char c, int remainder, StringNode prev) {
            this.c = c;
            this.remainder = remainder;
            this.prev = prev;
        }
    }
}