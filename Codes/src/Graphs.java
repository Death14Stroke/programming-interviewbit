import java.util.*;

class Graphs {
    // https://www.interviewbit.com/problems/region-in-binarymatrix/
    static int largestRegion(int[][] A) {
        int m = A.length, n = A[0].length;
        // length of largest connected component
        int res = 0;

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // unvisited node - start dfs
                if (A[i][j] == 1)
                    res = Math.max(res, dfs(i, j, A));
            }
        }

        return res;
    }

    // util to count no of nodes traversed in dfs
    private static int dfs(int i, int j, int[][] A) {
        // already visited node
        if (A[i][j] == 0)
            return 0;

        // mark current node as visited
        A[i][j] = 0;

        // 8 directions in which we can move ahead
        int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, 1}, {1, 1}, {1, 0}, {1, -1}, {0, -1}};
        int m = A.length, n = A[0].length;
        // no of nodes traversed in current dfs
        int noOfNodes = 1;

        // for each direction
        for (int[] dir : dirs) {
            int x = i + dir[0], y = j + dir[1];
            // if path does not exist
            if (x < 0 || x >= m || y < 0 || y >= n)
                continue;

            // add no of nodes traversed in this direction to total
            noOfNodes += dfs(x, y, A);
        }

        return noOfNodes;
    }

    // https://www.interviewbit.com/problems/level-order/
    @SuppressWarnings("ConstantConditions")
    static ArrayList<ArrayList<Integer>> levelOrder(Trees.TreeNode root) {
        ArrayList<ArrayList<Integer>> res = new ArrayList<>();
        // empty tree
        if (root == null)
            return res;

        // queue for level order traversal
        Queue<Trees.TreeNode> q = new LinkedList<>();
        q.add(root);

        while (!q.isEmpty()) {
            int n = q.size();
            ArrayList<Integer> level = new ArrayList<>();

            // traverse current level
            for (int i = 0; i < n; i++) {
                Trees.TreeNode front = q.poll();
                // add node to current level
                level.add(front.val);

                // append next level nodes to queue
                if (front.left != null)
                    q.add(front.left);
                if (front.right != null)
                    q.add(front.right);
            }

            res.add(level);
        }

        return res;
    }

    // https://www.interviewbit.com/problems/snake-ladder-problem/
    static int snakesAndLadders(int[][] A, int[][] B) {
        // create edge map for all the ladders and snakes
        int[] edges = new int[101];
        for (int[] ladder : A)
            edges[ladder[0]] = ladder[1];
        for (int[] snake : B)
            edges[snake[0]] = snake[1];

        // visited array for BFS
        boolean[] visited = new boolean[101];
        // queue for BFS
        Queue<GameNode> q = new LinkedList<>();
        // flag to check whether solution was found or not
        boolean isValid = false;

        // start from 1
        GameNode front = new GameNode();
        front.v = 1;
        front.dist = 0;

        visited[1] = true;
        q.add(front);

        // since in the board game all edges will have equal weight, BFS will give us the shortest path
        while (!q.isEmpty()) {
            front = q.poll();
            int v = front.v;

            // reached end. Mark valid flag as true and return
            if (v == 100) {
                isValid = true;
                break;
            }

            // try all 6 possible numbers on dice
            for (int j = v + 1; j <= (v + 6) && j <= 100; j++) {
                if (visited[j])
                    continue;

                // visit new node
                GameNode node = new GameNode();
                node.dist = front.dist + 1;
                visited[j] = true;

                // if any ladder or snake present, move up/down along that
                if (edges[j] != 0)
                    node.v = edges[j];
                else
                    node.v = j;

                q.add(node);
            }
        }

        // if solution not found return -1
        return isValid ? front.dist : -1;
    }

    // data class for each position on the board
    static class GameNode {
        // vertex on the board
        int v;
        // distance currently travelled
        int dist;
    }

    // https://www.interviewbit.com/problems/smallest-multiple-with-0-and-1/
    static String smallestMultiple(int n) {
        // base case
        if (n == 0)
            return "0";

        // start BFS from "1"
        Queue<StringNode> q = new LinkedList<>();
        q.add(new StringNode('1', 1, null));
        // set to check if remainder is seen or not. A smaller string with same remainder will generate
        // all the possible remainders that can be generated by a larger string with same remainder
        boolean[] remainderSet = new boolean[n];
        // last digit in the result string
        StringNode head = null;

        while (!q.isEmpty()) {
            StringNode front = q.poll();

            // found required number
            if (front.remainder % n == 0) {
                head = front;
                break;
            }

            // if remainder not seen before, perform BFS
            if (!remainderSet[front.remainder]) {
                remainderSet[front.remainder] = true;
                q.add(new StringNode('0', (front.remainder * 10) % n, front));
                q.add(new StringNode('1', (front.remainder * 10 + 1) % n, front));
            }
        }

        // build the reverse number
        StringBuilder builder = new StringBuilder();
        while (head != null) {
            builder.append(head.c);
            head = head.prev;
        }

        return builder.reverse().toString();
    }

    /// data class for BFS node
    static class StringNode {
        // current character in the result string
        char c;
        // remainder of the string formed till now
        int remainder;
        // pointer to the previous char's node in the string
        StringNode prev;

        StringNode(char c, int remainder, StringNode prev) {
            this.c = c;
            this.remainder = remainder;
            this.prev = prev;
        }
    }

    // https://www.interviewbit.com/problems/min-cost-path/
    static int minCostPath(int A, int B, String[] C) {
        // deque for 0-1 BFS
        Deque<MatrixNode> q = new LinkedList<>();
        // start with (0, 0)
        q.addLast(new MatrixNode(0, 0));

        // distance from (0, 0) to each node
        int[][] distance = new int[A][B];
        // initialize with max distance
        for (int[] d : distance)
            Arrays.fill(d, Integer.MAX_VALUE);
        // source to source distance is 0
        distance[0][0] = 0;

        // visited array for BFS
        boolean[][] visited = new boolean[A][B];

        // perform BFS
        while (!q.isEmpty()) {
            MatrixNode front = q.pollFirst();

            // four directions and their char representations
            int[][] dirs = {{-1, 0}, {0, 1}, {0, -1}, {1, 0}};
            char[] dirChars = {'U', 'R', 'L', 'D'};

            // mark current node as visited
            visited[front.x][front.y] = true;

            // for each direction (edge)
            for (int i = 0; i < 4; i++) {
                int x = front.x + dirs[i][0], y = front.y + dirs[i][1];
                // out of bounds or already visited
                if (x < 0 || x >= A || y < 0 || y >= B || visited[x][y])
                    continue;

                // if direction is same as the entry in matrix, weight of edge is 0 else it is 1
                int w = dirChars[i] == C[front.x].charAt(front.y) ? 0 : 1;

                // relax current edge
                if (distance[x][y] > distance[front.x][front.y] + w)
                    distance[x][y] = distance[front.x][front.y] + w;

                // if weight is 0, add to front of deque
                if (w == 0)
                    q.addFirst(new MatrixNode(x, y));
                    // else add to end of deque
                else
                    q.addLast(new MatrixNode(x, y));
            }
        }

        // distance from (0, 0) to (A - 1, B - 1)
        return distance[A - 1][B - 1];
    }

    // data class for each position in the matrix
    static class MatrixNode {
        int x, y;

        MatrixNode(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }

    // https://www.interviewbit.com/problems/commutable-islands/
    static int minCostBridges(int A, int[][] B) {
        int res = 0;
        // no of edges required for MST
        int reqNoOfEdges = A - 1;

        // union-find parent array
        int[] parent = new int[A + 1];
        Arrays.fill(parent, -1);

        // sort the edges in increasing order of weight
        Arrays.sort(B, Comparator.comparingInt(e -> e[2]));

        // for each edge
        for (int[] edge : B) {
            int u = edge[0], v = edge[1], weight = edge[2];

            // if both points are in same set, adding edge will form cycle
            if (find(parent, u) == find(parent, v))
                continue;

            // update minimum cost
            res += weight;
            // update no of edges remaining
            reqNoOfEdges--;
            // MST is complete
            if (reqNoOfEdges == 0)
                break;

            // add both endpoints to the same set
            union(parent, u, v);
        }

        return res;
    }

    // https://www.interviewbit.com/problems/possibility-of-finishing-all-courses-given-prerequisites/
    @SuppressWarnings("unchecked")
    static int canFinishCourses(int A, int[] B, int[] C) {
        // create adjacency list for the graph
        List<Integer>[] adj = new List[A + 1];
        for (int i = 1; i <= A; i++)
            adj[i] = new LinkedList<>();

        for (int i = 0; i < B.length; i++)
            adj[B[i]].add(C[i]);

        // boolean array to keep track of visited nodes
        boolean[] visited = new boolean[A + 1];
        // boolean array to keep track of nodes currently in DFS path stack
        boolean[] recStack = new boolean[A + 1];

        for (int i = 1; i <= A; i++) {
            // perform DFS for each connected component. If cycle, cannot complete courses
            if (!visited[i] && isDirectedCyclicUtil(i, adj, visited, recStack))
                return 0;
        }

        // no cycles. Can complete all courses in a topological order
        return 1;
    }

    // util to check for cycle in directed graph using DFS
    private static boolean isDirectedCyclicUtil(int u, List<Integer>[] adj, boolean[] visited, boolean[] recStack) {
        // mark current node as visited
        visited[u] = true;
        // mark current node as part of stack
        recStack[u] = true;

        // for each neighbour
        for (int v : adj[u]) {
            // if node already in stack, there is cycle
            if (recStack[v])
                return true;

            // if node is unvisited and it forms cycle
            if (!visited[v] && isDirectedCyclicUtil(v, adj, visited, recStack))
                return true;
        }

        // pop current node from stack
        recStack[u] = false;

        // no cycles starting from current node
        return false;
    }

    // https://www.interviewbit.com/problems/cycle-in-undirected-graph/
    // Approach 1 - using DFS (T.C O(V + E))
    @SuppressWarnings("unchecked")
    static int isUndirectedCycle(int A, int[][] B) {
        // create adjacency list for graph
        List<Integer>[] adj = new List[A + 1];
        for (int i = 1; i <= A; i++)
            adj[i] = new LinkedList<>();

        for (int[] edge : B) {
            int u = edge[0], v = edge[1];
            adj[u].add(v);
            adj[v].add(u);
        }

        // visited array for DFS
        boolean[] visited = new boolean[A + 1];
        // perform DFS for each connected component and check if cycle found
        for (int i = 1; i <= A; i++) {
            if (!visited[i] && isUndirectedCycleUtil(i, adj, visited, -1))
                return 1;
        }

        // no cycles found
        return 0;
    }

    // util to check cycle in undirected graph using DFS
    private static boolean isUndirectedCycleUtil(int u, List<Integer>[] adj, boolean[] visited, int parent) {
        // mark current node as visited
        visited[u] = true;

        // for each neighbour
        for (int v : adj[u]) {
            // if visited node and is not the parent of the current node, cycle found
            if (visited[v] && v != parent)
                return true;

            // if unvisited node and forms cycle
            if (!visited[v] && isUndirectedCycleUtil(v, adj, visited, u))
                return true;
        }

        // no cycles formed by any neighbours
        return false;
    }

    // https://www.interviewbit.com/problems/cycle-in-undirected-graph/
    // Approach 2 - using union find (T.C: O(E log V))
    static int isUndirectedCycleUnionFind(int A, int[][] B) {
        // initialize parent array for all nodes
        int[] parent = new int[A + 1];
        Arrays.fill(parent, -1);

        // for each edge
        for (int[] edge : B) {
            // find parents of both end points
            int x = find(parent, edge[0]);
            int y = find(parent, edge[1]);

            // if in same subset, cycle exists
            if (x == y)
                return 1;

            // perform union of both parents
            union(parent, x, y);
        }

        // no cycles found
        return 0;
    }

    // util to perform find operation in disjoint set
    private static int find(int[] parent, int i) {
        // find the root node of the set
        while (parent[i] != -1)
            i = parent[i];

        return i;
    }

    // util to perform union operation in disjoint set
    private static void union(int[] parent, int x, int y) {
        // find parents of both nodes
        x = find(parent, x);
        y = find(parent, y);

        // make either node as parent of other node
        parent[x] = y;
    }

    // https://www.interviewbit.com/problems/black-shapes/
    static int blackShapes(String[] A) {
        int m = A.length, n = A[0].length();
        // no of connected components
        int res = 0;

        boolean[][] visited = new boolean[m][n];

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                // if character is 'X' and not visited
                if (A[i].charAt(j) == 'X' && !visited[i][j]) {
                    // update count
                    res++;
                    // perform DFS
                    blackShapesUtil(i, j, m, n, A, visited);
                }
            }
        }

        return res;
    }

    // util to perform DFS for each connected component
    private static void blackShapesUtil(int i, int j, int m, int n, String[] A, boolean[][] visited) {
        // mark current position as visited
        visited[i][j] = true;

        int[][] dirs = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};

        // for all 4 directions
        for (int[] dir : dirs) {
            int x = i + dir[0], y = j + dir[1];

            // if no path or character is 'O' or already visited
            if (x < 0 || x >= m || y < 0 || y >= n || A[x].charAt(y) == 'O' || visited[x][y])
                continue;

            // perform DFS
            blackShapesUtil(x, y, m, n, A, visited);
        }
    }

    // https://www.interviewbit.com/problems/cycle-in-directed-graph/
    @SuppressWarnings("unchecked")
    static int isDirectedCycle(int A, int[][] B) {
        // create adjacency list
        List<Integer>[] adj = new List[A + 1];
        for (int i = 1; i <= A; i++)
            adj[i] = new LinkedList<>();

        for (int[] edge : B)
            adj[edge[0]].add(edge[1]);

        // boolean array to keep track of visited nodes
        boolean[] visited = new boolean[A + 1];
        // boolean array to keep track of nodes currently in DFS path stack
        boolean[] recStack = new boolean[A + 1];

        for (int i = 1; i <= A; i++) {
            // perform DFS for each connected component to check for cycle
            if (!visited[i] && isDirectedCyclicUtil(i, adj, visited, recStack))
                return 1;
        }

        // no cycles found
        return 0;
    }

    // https://www.interviewbit.com/problems/two-teams/
    @SuppressWarnings("unchecked")
    static int twoTeams(int A, int[][] B) {
        // adjacency list for the undirected graph
        List<Integer>[] adj = new List[A + 1];
        for (int i = 1; i <= A; i++)
            adj[i] = new LinkedList<>();

        for (int[] edge : B) {
            adj[edge[0]].add(edge[1]);
            adj[edge[1]].add(edge[0]);
        }

        // color array for bipartite partitioning - (0, 1) are the colors
        int[] color = new int[A + 1];
        Arrays.fill(color, -1);

        for (int i = 1; i <= A; i++) {
            // if any connected component is not bipartite, cannot form 2 teams
            if (color[i] == -1 && !isBipartiteUtil(i, adj, color))
                return 0;
        }

        // graph is bipartite - can form 2 teams
        return 1;
    }

    // util to check if connected component is bipartite or not using BFS
    private static boolean isBipartiteUtil(int src, List<Integer>[] adj, int[] color) {
        // queue for BFS
        Queue<Integer> q = new LinkedList<>();
        q.add(src);

        // color source vertex as 0
        color[src] = 0;

        while (!q.isEmpty()) {
            int u = q.poll();

            // for each neighbour of u
            for (int v : adj[u]) {
                // if same color, graph is not bipartite
                if (color[v] == color[u])
                    return false;

                // if not colored, color with opposite color and add to queue for BFS
                if (color[v] == -1) {
                    color[v] = 1 - color[u];
                    q.add(v);
                }
            }
        }

        // graph is bipartite
        return true;
    }

    // https://www.interviewbit.com/problems/path-in-directed-graph/
    @SuppressWarnings("unchecked")
    static int isPath(int A, int[][] B) {
        // create adjacency list for the graph
        List<Integer>[] adj = new List[A + 1];
        for (int i = 1; i <= A; i++)
            adj[i] = new ArrayList<>();

        for (int[] edge : B)
            adj[edge[0]].add(edge[1]);

        // perform DFS till the last node is reached starting from 1
        return isPathUtil(1, A, adj, new boolean[A + 1]) ? 1 : 0;
    }

    // util to check if node A is reached or not using DFS
    private static boolean isPathUtil(int u, int A, List<Integer>[] adj, boolean[] visited) {
        // reached end
        if (u == A)
            return true;

        // mark current node as visited
        visited[u] = true;

        // for each neighbour
        for (int v : adj[u]) {
            // if unvisited and has a path to node A, return true
            if (!visited[v] && isPathUtil(v, A, adj, visited))
                return true;
        }

        // no path found to node A
        return false;
    }
}